**musiclib_tagclean.sh**

Walks a target MP3 file or directory (optionally recursively) and normalizes tags into a MusicLib‑friendly state by merging any legacy ID3v1 data into ID3v2.3, then removing the v1 tag entirely, optionally stripping APE and ReplayGain metadata, and embedding album art when it can find a suitable JPEG in the same directory. It wraps all of this with safety rails: required tool checks (kid3‑cli, exiftool, optional id3v2), dry‑run and verbose modes, configurable backup directories and retention windows, and automatic cleanup of old backup files before processing.

Operationally, it computes whether a given MP3 actually needs changes (based on tag presence, requested APE/ReplayGain removal, and missing embedded art) and only then creates and verifies a backup before modifying the file. Depending on the mode (full, art‑only, ape‑only, rg‑only), it executes the corresponding tag operations, verifies that the resulting file is intact (restoring from backup on failure), and prints a final summary of counts for files processed, tags merged/removed, art embedded, errors, and backup location.

Loudness normalization

RSGain is preferred because it implements modern ReplayGain 2.0 loudness normalization using the EBU R128/ITU-R BS.1770 standard, giving more psychoacoustically accurate loudness and peak measurements than legacy APE/ReplayGain toolchains while leaving the underlying audio untouched. It also integrates clipping protection at scan time, offers configurable peak calculation (sample vs. true peak), and provides a “batteries‑included” workflow that can scan and tag an entire library in one pass, reducing the scripting glue and format‑specific quirks you typically juggle with older APE/ReplayGain solutions.

Compared with traditional ReplayGain tags and MP3Gain/APE‑based workflows, RSGain writes standardized ReplayGain 2.0 metadata for many formats (MP3, FLAC, AIFF, APE, etc.), aligning with current ecosystem expectations and newer tools like the MusicBrainz Picard ReplayGain 2.0 plugin. APE tags and classic ReplayGain fields (e.g., MP3GAIN_* in APEv2 or legacy REPLAYGAIN_* in ID3) tend to be less portable, more error‑prone across players, and tied to outdated assumptions (e.g., fixed 89 dB reference level, inconsistent clipping handling), whereas RSGain’s R128‑based approach and tag conventions are designed to be cross‑platform, future‑proof, and safer for large libraries that need consistent volume normalization without destructive gain changes.

**musiclib_audacious.sh**

A song-change handler for the Audacious music player that ties each currently playing track into the personal `musiclib` database and Conky-based display system. When a new track starts, it verifies Audacious is running, gets the file path, extracts album art into a display directory, and writes key metadata (artist, album, year, title, comment) plus a numeric rating (from the Grouping tag) into text files that Conky can render. It also computes and shows the last played date for the track from `musiclib.dsv`, and selects the appropriate star-rating PNG (or fires a passive `kdialog` prompt if unrated) so the desktop UI stays in sync with the current song state.

In the background, the script monitors playback to a configurable “scrobble” threshold (effectively 50% of the track, bounded between 30 seconds and 4 minutes [1]) and, once reached, records a precise SQL-style timestamp for the listen. That timestamp is written back into the `musiclib` database and into the track’s tag (with an automatic tag-rebuild and logging path if `kid3-cli` fails), appended to a local `audacioushist.log` history file, and used to refresh the “last played” display. The script also includes a watchdog to restart Conky if needed, and a custom section that dynamically pads or trims the on-screen track detail text to fit around a weather widget layout.

**musiclib_rate.sh**

Bash helper script that lets you assign a 0–5 star rating to the track currently playing in Audacious, then propagates that rating consistently through the ecosystem. It validates the numeric rating, confirms that Audacious is running and a real file is playing, then maps the star value to a POPM “popularimeter” score, a textual group/priority descriptor, and a corresponding star image filename. Using `kid3-cli`, it writes the POPM value (and a descriptive “Work”/TIT1 frame) into the file’s tags, with a recovery path that attempts to rebuild broken tags and retries on failure so that rating writes are robust instead of best-effort.

Beyond tagging, the script updates the central `musiclib.dsv` database under a file lock, retrying a few times if the DB is busy and surfacing lock timeouts as explicit errors so you do not silently lose ratings. It looks up the track’s row by filepath, updates both the `Rating` and `GroupDesc` columns if present, then refreshes Conky-facing status files by writing the group descriptor to `currgpnum.txt` and copying the appropriate star image into a known output path, which lets the Conky setup show the changed rating. Optional desktop notifications via `kdialog` indicate when a rating is processing, when it fails (e.g., DB busy, tag write error), and when it succeeds, and an optional `logmessage` hook records the operation for later auditing.

**musiclib_new_tracks.sh**

Import pipeline for newly downloaded music that turns ad‑hoc ZIP/MP3 downloads into normalized, library‑ready tracks under the configured music repository. It takes an artist name (or prompts for one), normalizes it into a filesystem‑safe artist folder, validates config and dependencies via `musiclib_utils.sh`, and inspects the “new downloads” directory for either a single ZIP or a batch of MP3s, enforcing guardrails like “no mixed ZIP/MP3” and “only one ZIP at a time.” If a ZIP is present, it is renamed (spaces→underscores, lowercased), extracted, and removed, after which the script pauses explicitly so you can clean up tags in kid3‑qt before continuing.

Once MP3s are present, the script runs a tag‑driven rename using kid3‑cli (`track_-_artist_-_title`), then aggressively normalizes filenames for filesystem safety (lowercase, restricted charset, collapsed underscores). It then optionally loudness‑normalizes the directory with `rsgain`, derives a normalized album name from the tags of the first file (with fallbacks like `unknown_album_YYYYMMDD` or `various`), creates an artist/album directory under the music repo, and moves the MP3s there. For each file it extracts metadata, computes duration, assigns a new track and album ID, appends a caret‑delimited record to the `musiclib.dsv` database, and synchronizes key tag fields (custom last‑played, rating, group description) via kid3‑cli, logging each addition and printing a success/failure summary at the end.

**musiclib_mobile.sh**

Bash helper for the MusicLib system that pushes an Audacious `.audpl` playlist and its referenced audio files to an Android device via KDE Connect. It validates dependencies, pings the target device ID, and forces you to manually clear stale phone downloads before proceeding, then URL-decodes `uri=file://` entries from the playlist to build a transfer list and a matching `.m3u` that contains only the basenames used on the phone side. The script sends the playlist first, streams each audio file with `kdeconnect-cli --share`, logs detailed stats (track count and MB transferred) into a dedicated mobile log, and writes per‑playlist metadata (`.meta` timestamp and `.tracks` file list) under the MusicLib mobile directory so later workflows can reason about what was sent when.

Its second major role is to synthesize “mobile last-played” timestamps for tracks you listened to on the phone and merge those into the main MusicLib database, approximating when each track was played during the time window between uploads. Using the previous playlist’s upload time as a start, current time as an end, and the cumulative byte size of all tracks, it computes a proportional play time for each file, converts that to the SQL serial format used by MusicLib, and either updates existing entries or reminds user to add new tracks using `musiclib_new_tracks.sh`, while preserving any desktop scrobbles that fall inside the same window. A small command dispatcher provides `upload`, `update-lastplayed`, `status`, `logs` (with filters like `errors`, `warnings`, `stats`, `today`), and `cleanup` for orphaned `.meta`/`.tracks` files, with defensive checks for clock skew, zero-size playlists, missing files, and log rotation beyond 10 MB.

**musiclib_build.sh**

Rebuilds, or initially creates the MusicLib track database from scratch by scanning a given root music directory, extracting tag data from all supported audio files, and writing a fresh `^`‑delimited `musiclib.dsv`with new sequential track IDs and regenerated album IDs. It uses `exiftool` for core tags (artist, album, album artist, title, genre, grouping, duration) and POPM ratings, calculates track length, and, in full mode, uses `kid3-cli` to preserve `LastTimePlayed` and custom tag fields, with options for quiet mode, no header, configurable minimum directory depth, and safety/test behavior that can write to a temporary file instead of replacing the live DB.

Operationally, it validates the target music directory, optionally backs up the existing database, counts and sorts all audio files, estimates total runtime, and then streams progress statistics (files processed per minute and ETA) as it populates the new DB line by line. A fast mode (`--skip-custom`) skips custom tag extraction to increase processing speed at the cost of resetting any existing lastplayed-history to zero, and on completion the script prints a summary (total tracks, unique album count, average rate, elapsed time, output path, and backup location if used) and logs the rebuild event via the shared MusicLib logging utilities.

**musiclib_utils.sh**

A shared Bash utility library that centralizes common functions used across the MusicLib scripts, primarily focused on configuration loading, dependency validation, ID generation, metadata handling, and robust file/database management. It is designed to be sourced by other scripts so they can operate against a consistent configuration, logging, and error-handling framework while manipulating a flat-file database of tracks and their associated tags.

First, the script provides functions to load the main MusicLib configuration from `musiclib.conf`, verify that required tools like `exiftool`, `kid3-cli`, `kdeconnect-cli`, and `bc` are installed, and to check arbitrary tool requirements on demand. This ensures any consumer script fails fast with clear diagnostics if the environment is misconfigured or missing critical utilities, rather than failing later with opaque command errors.

Second, it implements database helper functions for the DSV-backed music database, including computing the next available track ID, finding or creating album IDs, validating the database header format, and converting Unix epoch timestamps into the Excel/SQL serial date format used for LastTimePlayed fields. These helpers encapsulate all the row/field parsing logic (using `tail`, `awk`, `cut`, `grep`, `sort`, and `bc`) so higher-level scripts can treat the database as an abstracted service rather than hand-rolling parsing every time.

Third, the script encapsulates track-level metadata and duration handling via `exiftool`, offering functions to extract artist/album/albumartist/title/genre into a caret-delimited record, to compute song lengths in milliseconds from mixed duration formats, and to convert that into the “seconds plus 000” length field convention. It also probes tag structure (ID3v1, ID3v2, APE) and whether a file has embedded album art, enabling consumer scripts to branch on tag presence or artwork state without duplicating the exiftool plumbing.

Fourth, it provides an `update_lastplayed` routine that locates a track row by filepath, identifies the LastTimePlayed column index from the header, patches the DSV row in place, and then writes the same timestamp into a custom tag (Songs-DB_Custom1) via `kid3-cli` with automatic tag-rebuild-and-retry if a write fails. This gives you a single, consistent mechanism for synchronizing logical “last played” state between the flat-file database and on-disk tags, with logging hooks to capture any anomalies.

Fifth, `musiclib_utils.sh` contains generalized logging and backup utilities, including a `log_message` helper that timestamps messages to both stdout and a configured log file, plus routines to back up the main database (keeping only the latest five snapshots) and a generic `backup_file` that creates timestamped copies with verification and optional cleanup of aged backups by pattern. Additional helpers verify that backups match originals, remove backup artifacts, and prune stale files, giving the higher-level scripts a reusable, defensive layer for protecting and rotating persistent state.

Finally, the script introduces a more formal error and concurrency model with `error_exit` for JSON-formatted error reporting and a small file-locking framework for serialized database access. It tracks a global lock file descriptor (`DB_LOCK_FD`), implements `acquire_db_lock` and `release_db_lock`, and wraps arbitrary commands with `with_db_lock`, which sets traps to guarantee lock release on exit or signals, allowing multiple MusicLib components to coordinate safe concurrent access to the shared database without corrupting it.

**musiclib_utils_tag_functions.sh**

Provides the tag-repair and normalization layer for the MusicLib system, focused on ID3v2 frames and safe, filtered rebuilding of tags using `exiftool` and `kid3-cli` as backends. It first manages an exclude list of “unwanted” or non-essential ID3v2 frames, loading this from configurable files or built-in defaults into an associative array, and exposes an `is_frame_allowed` helper so only approved frames (plus certain whitelisted `TXXX` user frames and ReplayGain fields) are ever written back into audio files.

On top of that policy layer, it implements two main workflows: `rebuild_tag` for repairing corrupted tags on tracks already in the MusicLib database, and `normalize_new_track_tags` for cleaning up tags on new files before they are imported. Both functions extract full metadata and album art to a temp workspace, strip all existing ID3/APE tags, then rebuild clean ID3v2.3 tags—`rebuild_tag` pulling authoritative values (artist/album/title/rating, play tracking, grouping, etc.) from the MusicLib DB and preserving non-DB data like ReplayGain, while `normalize_new_track_tags` relies solely on the file’s current metadata.

**musiclib_tagrebuild.sh**

Repairs corrupted or malformed ID3 tags in MP3 files within a personal MusicLib database system. It targets files or directories specified by the user, processing only those entries present in the `musiclib.dsv` database, and extracts authoritative metadata like artist, album, title, and rating from the database while preserving non-database fields such as ReplayGain and album art.

The script supports options for recursive directory scanning, dry-run previews, verbose logging, and custom backup directories, creating timestamped backups before modifications via the `rebuildtag` function from `musiclibutilstagfunctions.sh` (loaded dynamically). It skips non-database files non-fatally, tracks statistics on processed files, rebuilt tags, skips, and errors, and cleans up old backups older than a configurable age.

**musiclib_process_pending.sh**

A deferred-execution handler that processes queued database operations created when lock contention prevents immediate writes during normal MusicLib workflows. When scripts like `musiclib_rate.sh` encounter a busy database, they write the pending operation (timestamp, script name, operation type, and arguments) to a `.pending_operations` queue file instead of failing, and then trigger this processor to retry them once the lock is released. The script can run automatically after database-writing operations complete, or be invoked manually or via a cron timer, making the rating/database system resilient to transient lock conflicts without user intervention.

Operationally, it acquires a non-blocking lock on the pending file to prevent concurrent processors from colliding, then iterates through each queued operation line-by-line, currently handling the `rate` operation which updates both the database (Rating and GroupDesc columns) and the file's ID3 tags (POPM and TIT1 frames) via `kid3-cli`. For each successful operation it removes the line from the queue, logs completion, and optionally fires a `kdialog` notification; if an operation still fails (e.g., database remains locked), it is left in the queue for the next retry cycle. On exit, the script cleans up malformed or unknown operations, deletes the queue file if empty, releases all locks, and returns exit code 0 (success or no pending work) or 2 (system error accessing the pending file), giving callers a clear signal of whether any backlog remains.

**musiclib_cli_dispatcher.sh**

Central command dispatcher that provides a unified CLI entrypoint for all MusicLib operations, mapping high-level subcommands onto underlying shell scripts while handling configuration, argument parsing, logging, and exit-code normalization. Instead of calling individual scripts directly, users and future GUI frontends interact primarily through this dispatcher (`musiclib-cli`), which encapsulates the “public API” surface of the MusicLib system in a single, user-facing binary-like interface.

At startup, the dispatcher loads `musiclib.conf` via `musiclib_utils.sh`, validates core dependencies, and parses a small, well-defined set of subcommands such as `rate`, `now-playing`, `tagclean`, `mobile`, `new-tracks`, `build-db`, and `status`, each with its own flags and short usage synopsis. For each recognized subcommand, it validates required positional arguments, performs early sanity checks (e.g., that the target file or directory exists), and then invokes the corresponding script with a normalized environment, propagating only essential variables and using a consistent logging prefix so logs remain readable and grep-friendly.

The dispatcher also standardizes error handling by mapping common failure modes from underlying scripts (missing tools, bad configuration, lock timeouts, invalid arguments) into a small set of documented exit codes (0 = success, 1 = user/config error, 2 = system/runtime error, 3 = external dependency failure). This lets shell users and future GUI code reason about outcomes in a predictable way, without needing to know the internals of each script. A global `--help` view summarizes all available commands and points to more detailed documentation, while `musiclib-cli <subcommand> --help` passes through per-command help text, establishing a consistent, discoverable UX around the otherwise sprawling shell script suite.

**musiclib_status.sh**

Read-only status and diagnostics script that summarizes the health and key metrics of the MusicLib ecosystem in a single, human-readable report. It is primarily invoked via `musiclib-cli status` to give you a “cockpit view” of the library without touching any state, making it safe to run anytime, including from cron, systemd timers, or monitoring tools.

The script loads configuration, verifies that critical paths (music repository, database file, mobile metadata directory, Conky output directory) exist, and then reports high-level stats such as total track count, unique albums, percentage of rated tracks, and the age of the last successful database rebuild, drawing from `musiclib.dsv` and log metadata. It also performs lightweight dependency checks (`exiftool`, `kid3-cli`, `kdeconnect-cli`, `rsgain`, `audtool`) and summarizes whether each is installed and reachable, flagging any missing tools as warnings.

For operational insight, `musiclib_status.sh` inspects the pending-operations queue, recent error entries from the shared log, and the size/rotation status of major log files, surfacing potential problems like a stuck rating queue, rapidly growing logs, or repeated tag-rebuild failures. When run with a `--json` flag (planned for Phase 0), it emits a structured JSON document mirroring the human-readable report, suitable for consumption by a future GUI, system dashboards, or external monitoring agents.

**musiclib_lock_inspector.sh**

Diagnostic tool focused on inspecting and debugging the flat-file locking and concurrency behavior of the MusicLib database. It is designed for developers and power users to understand why operations might be blocked, slow, or intermittently failing due to lock contention, especially as more components (desktop, mobile, future GUI) begin to access the shared `musiclib.dsv` concurrently.

When invoked, it checks whether the database lock file exists, which process (PID/command line) currently holds it (using `/proc` introspection where available), and how long the lock has been held relative to a configurable “expected max hold time.” It can optionally enumerate all processes that have `musiclib.dsv` or related files open to help identify misbehaving tools or scripts that are bypassing the standard lock wrapper. A “verbose” mode prints the recent history of lock acquisition and release events from the shared log, reconstructing a timeline of which component held the lock when, and for how long, making it easier to spot patterns like a mobile sync run that monopolizes the database.

In the future, `musiclib_lock_inspector.sh` can integrate with `musiclib_process_pending.sh` to suggest or automatically trigger retries of stuck operations once a stale lock is detected, but even in its initial form it gives a clear, centralized lens into the concurrency layer, reducing the need to add ad-hoc debug logging to individual scripts when tracking down contention issues.

**musiclib_conky_refresh.sh**

Utility script responsible for regenerating the Conky-facing display files that show “now playing” metadata, rating stars, and auxiliary status indicators, without requiring a full song-change event from Audacious. It acts as a bridge between the canonical `musiclib.dsv` database and the lightweight text/PNG assets that Conky reads, ensuring that the desktop display can be refreshed on demand after out-of-band changes such as manual rating edits, database rebuilds, or tag repairs.

Given a target track (either by explicit path or “current track” resolution via `audtool`), the script looks up its row in the database, extracts key fields (artist, album, title, year, rating, group description, last played timestamp), and writes them into the expected Conky text files in the configured output directory. It also selects and copies the appropriate star-rating image based on the normalized rating field, and can optionally re-extract album art from the file if the existing cached image is missing or stale. Hooks are included for future integration with weather or system-status overlays so that the Conky layout remains visually consistent even as content changes.

This script is intended to be lightweight and idempotent, making it safe to call frequently (e.g., from `musiclib_rate.sh` after a rating change, or from a periodic systemd timer) without perturbing playback or the underlying database beyond simple reads. In combination with `musiclib_audacious.sh`, it helps keep the Conky UI responsive and accurate, even in edge cases where Audacious itself has not emitted a fresh song-change event.

**musiclib_init_config.sh**

Interactive first-run setup wizard that guides new users through initial MusicLib configuration. It detects whether Audacious and `audtool` are installed, scans common filesystem locations (`/mnt/music`, `~/Music`, etc.) for music directories, prompts for the music repository path and download directory, creates the XDG directory structure under `~/.config/musiclib/` and `~/.local/share/musiclib/`, and writes a `musiclib.conf` with all detected values plus sensible defaults for lock timeout, scrobble threshold, and star-image paths. A `--force` flag allows overwriting an existing configuration.

When Audacious is detected, the wizard prints step-by-step instructions for enabling the Song Change plugin and configuring it to call `musiclib_audacious.sh` on each track change. It can optionally verify the integration by checking whether Audacious is running, testing the hook script, and validating that Conky output files are generated. At the end of the wizard, it offers to build the initial database by invoking `musiclib_build.sh`, and prints a summary of next steps (rate tracks, import new music, etc.). The dispatcher auto-triggers this wizard when any command is run without a valid configuration file.

**musiclib_audacious_setup.sh**

Helper script for Audacious Song Change plugin configuration, called by `musiclib_init_config.sh` during the setup wizard when Audacious is detected. It checks whether Audacious is installed, verifies `audtool` availability, and prints the manual steps needed to enable the Song Change plugin and set the hook command path. Since the Audacious plugin configuration cannot be modified programmatically, this script's role is instructional rather than automated. It is not exposed as a standalone CLI command — users interact with it through `musiclib-cli setup`.

**musiclib_audacious_test.sh**

Diagnostic and verification script for Audacious integration, called by `musiclib_init_config.sh` during the setup wizard's optional verification step. It runs a sequence of checks: confirms Audacious is running via `pgrep`, verifies `audtool` is on the PATH, checks whether a track is currently playing, locates and confirms the hook script is present and executable, triggers the hook manually, and validates that Conky output files (`detail.txt`, `starrating.png`) are updated afterward. Each check reports pass/fail status with guidance on how to resolve failures. It is not exposed as a standalone CLI command — users interact with it through `musiclib-cli setup`.


## Standalone Utilities

The following scripts are standalone utilities that operate outside the normal dispatcher and API contract. They are not invoked by the GUI or CLI dispatcher.

**conform_musiclib.sh**

Pre-setup utility that renames non-conforming music filenames to MusicLib naming standards before database creation. It targets users whose music library has the correct directory structure (`artist/album/`) but has filenames containing uppercase letters, spaces, accented characters, or other special characters that would cause inconsistent behavior in path matching, mobile sync, and other MusicLib operations.

The script scans all music files in the specified repository, identifies filenames that violate MusicLib's naming conventions (lowercase only, underscores instead of spaces, safe ASCII characters), and either reports what would change (dry-run mode, the default) or performs the renames (with `--execute` flag). For safety, it uses a copy-verify-delete workflow: it copies the file to the new conforming name, verifies the copy succeeded by comparing file sizes, and only then deletes the original. If a target filename already exists (collision), the file is skipped with a warning.

Non-ASCII characters are transliterated to ASCII equivalents using Perl's UTF-8 transliteration (with iconv fallback), so accented characters like `é`, `ñ`, or `ü` become their unaccented counterparts. The script writes detailed logs to `~/.local/share/musiclib/logs/conform_YYYYMMDD_HHMMSS.log` for post-run review. It can read `MUSIC_REPO` from `musiclib.conf` if available, or accept the path as a command-line argument.

This tool is referenced by `musiclib_init_config.sh` during the setup wizard's library analysis phase. If non-conforming filenames are detected and the user chooses to exit setup to reorganize their library, the wizard points them to this utility. It lives in `~/.local/share/musiclib/utilities/` rather than the main `bin/` directory to emphasize its standalone, pre-setup nature.

[1] Bounded between 30 seconds and 4 minutes means that, even though the script first computes the scrobble point as 50% of the track length, it then enforces a hard minimum of 30 seconds and a hard maximum of 240 seconds for that wait time. If half the track is shorter than 30 seconds it will still wait 30 seconds, and if half the track is longer than 4 minutes it will cap the wait at 4 minutes instead of waiting longer. The wait time matters because the script only scrobbles once it has observed that much continuous playback time on that specific track; if you pause for more than 4 minutes, you can break the assumption that “time elapsed since starting this track ≈ time actually listened.” The loop is literally counting three‑second “still playing this same file” checks up to a capped threshold (max 240 seconds), so any long pause (status no longer “playing” or file changed) stops the monitor and prevents a scrobble, even if wall‑clock time has marched past that 4‑minute cap.
