**musiclib_tagclean.sh**

Walks a target MP3 file or directory (optionally recursively) and normalizes tags into a MusicLib‑friendly state by merging any legacy ID3v1 data into ID3v2.3, then removing the v1 tag entirely, optionally stripping APE and ReplayGain metadata, and embedding album art when it can find a suitable JPEG in the same directory. It wraps all of this with safety rails: required tool checks (kid3‑cli, exiftool, optional id3v2), dry‑run and verbose modes, configurable backup directories and retention windows, and automatic cleanup of old backup files before processing.
​

Operationally, it computes whether a given MP3 actually needs changes (based on tag presence, requested APE/ReplayGain removal, and missing embedded art) and only then creates and verifies a backup before modifying the file. Depending on the mode (full, art‑only, ape‑only, rg‑only), it executes the corresponding tag operations, verifies that the resulting file is intact (restoring from backup on failure), and prints a final summary of counts for files processed, tags merged/removed, art embedded, errors, and backup location.

Loudness normalization

RSGain is preferred because it implements modern ReplayGain 2.0 loudness normalization using the EBU R128/ITU-R BS.1770 standard, giving more psychoacoustically accurate loudness and peak measurements than legacy APE/ReplayGain toolchains while leaving the underlying audio untouched. It also integrates clipping protection at scan time, offers configurable peak calculation (sample vs. true peak), and provides a “batteries‑included” workflow that can scan and tag an entire library in one pass, reducing the scripting glue and format‑specific quirks you typically juggle with older APE/ReplayGain solutions.

Compared with traditional ReplayGain tags and MP3Gain/APE‑based workflows, RSGain writes standardized ReplayGain 2.0 metadata for many formats (MP3, FLAC, AIFF, APE, etc.), aligning with current ecosystem expectations and newer tools like the MusicBrainz Picard ReplayGain 2.0 plugin. APE tags and classic ReplayGain fields (e.g., MP3GAIN_* in APEv2 or legacy REPLAYGAIN_* in ID3) tend to be less portable, more error‑prone across players, and tied to outdated assumptions (e.g., fixed 89 dB reference level, inconsistent clipping handling), whereas RSGain’s R128‑based approach and tag conventions are designed to be cross‑platform, future‑proof, and safer for large libraries that need consistent volume normalization without destructive gain changes.

**musiclib_audacious.sh**

A song-change handler for the Audacious music player that ties each currently playing track into the personal `musiclib` database and Conky-based display system. When a new track starts, it verifies Audacious is running, gets the file path, extracts album art into a display directory, and writes key metadata (artist, album, year, title, comment) plus a numeric rating (from the Grouping tag) into text files that Conky can render. It also computes and shows the last played date for the track from `musiclib.dsv`, and selects the appropriate star-rating PNG (or fires a passive `kdialog` prompt if unrated) so the desktop UI stays in sync with the current song state. 

In the background, the script monitors playback to a configurable “scrobble” threshold (effectively 50% of the track, bounded between 30 seconds and 4 minutes [1]) and, once reached, records a precise SQL-style timestamp for the listen. That timestamp is written back into the `musiclib` database and into the track’s tag (with an automatic tag-rebuild and logging path if `kid3-cli` fails), appended to a local `audacioushist.log` history file, and used to refresh the “last played” display. The script also includes a watchdog to restart Conky if needed, and a custom section that dynamically pads or trims the on-screen track detail text to fit around a weather widget layout.

**musiclib_rate.sh**

Bash helper script that lets you assign a 0–5 star rating to the track currently playing in Audacious, then propagates that rating consistently through the ecosystem. It validates the numeric rating, confirms that Audacious is running and a real file is playing, then maps the star value to a POPM “popularimeter” score, a textual group/priority descriptor, and a corresponding star image filename. Using `kid3-cli`, it writes the POPM value (and a descriptive “Work”/TIT1 frame) into the file’s tags, with a recovery path that attempts to rebuild broken tags and retries on failure so that rating writes are robust instead of best-effort.

Beyond tagging, the script updates the central `musiclib.dsv` database under a file lock, retrying a few times if the DB is busy and surfacing lock timeouts as explicit errors so you do not silently lose ratings. It looks up the track’s row by filepath, updates both the `Rating` and `GroupDesc` columns if present, then refreshes Conky-facing status files by writing the group descriptor to `currgpnum.txt` and copying the appropriate star image into a known output path, which lets the Conky setup show the changed rating. Optional desktop notifications via `kdialog` indicate when a rating is processing, when it fails (e.g., DB busy, tag write error), and when it succeeds, and an optional `logmessage` hook records the operation for later auditing. 

**musiclib_new_tracks.sh**

Import pipeline for newly downloaded music that turns ad‑hoc ZIP/MP3 downloads into normalized, library‑ready tracks under the configured music repository.  It takes an artist name (or prompts for one), normalizes it into a filesystem‑safe artist folder, validates config and dependencies via `musiclib_utils.sh`, and inspects the “new downloads” directory for either a single ZIP or a batch of MP3s, enforcing guardrails like “no mixed ZIP/MP3” and “only one ZIP at a time.”  If a ZIP is present, it is renamed (spaces→underscores, lowercased), extracted, and removed, after which the script pauses explicitly so you can clean up tags in kid3‑qt before continuing.

Once MP3s are present, the script runs a tag‑driven rename using kid3‑cli (`track_-_artist_-_title`), then aggressively normalizes filenames for filesystem safety (lowercase, restricted charset, collapsed underscores).  It then optionally loudness‑normalizes the directory with `rsgain`, derives a normalized album name from the tags of the first file (with fallbacks like `unknown_album_YYYYMMDD` or `various`), creates an artist/album directory under the music repo, and moves the MP3s there.  For each file it extracts metadata, computes duration, assigns a new track and album ID, appends a caret‑delimited record to the `musiclib.dsv` database, and synchronizes key tag fields (custom last‑played, rating, group description) via kid3‑cli, logging each addition and printing a success/failure summary at the end. 

**musiclib_mobile.sh**

Bash helper for the MusicLib system that pushes an Audacious `.audpl` playlist and its referenced audio files to an Android device via KDE Connect. It validates dependencies, pings the target device ID, and forces you to manually clear stale phone downloads before proceeding, then URL-decodes `uri=file://` entries from the playlist to build a transfer list and a matching `.m3u` that contains only the basenames used on the phone side. The script sends the playlist first, streams each audio file with `kdeconnect-cli --share`, logs detailed stats (track count and MB transferred) into a dedicated mobile log, and writes per‑playlist metadata (`.meta` timestamp and `.tracks` file list) under the MusicLib mobile directory so later workflows can reason about what was sent when. 

Its second major role is to synthesize “mobile last-played” timestamps for tracks you listened to on the phone and merge those into the main MusicLib database, approximating when each track was played during the time window between uploads. Using the previous playlist’s upload time as a start, current time as an end, and the cumulative byte size of all tracks, it computes a proportional play time for each file, converts that to the SQL serial format used by MusicLib, and either updates existing entries or reminds user to add new tracks using `musiclib_new_tracks.sh`, while preserving any desktop scrobbles that fall inside the same window. A small command dispatcher provides `upload`, `update-lastplayed`, `status`, `logs` (with filters like `errors`, `warnings`, `stats`, `today`), and `cleanup` for orphaned `.meta`/`.tracks` files, with defensive checks for clock skew, zero-size playlists, missing files, and log rotation beyond 10 MB.

**musiclib_build.sh**

Rebuilds, or initially creates the MusicLib track database from scratch by scanning a given root music directory, extracting tag data from all supported audio files, and writing a fresh `^`‑delimited `musiclib.dsv`with new sequential track IDs and regenerated album IDs. It uses `exiftool` for core tags (artist, album, album artist, title, genre, grouping, duration) and POPM ratings, calculates track length, and, in full mode, uses `kid3-cli` to preserve `LastTimePlayed` and custom tag fields, with options for quiet mode, no header, configurable minimum directory depth, and safety/test behavior that can write to a temporary file instead of replacing the live DB.

Operationally, it validates the target music directory, optionally backs up the existing database, counts and sorts all audio files, estimates total runtime, and then streams progress statistics (files processed per minute and ETA) as it populates the new DB line by line. A fast mode (`--skip-custom`) skips custom tag extraction to increase processing speed at the cost of resetting any existing lastplayed-history to zero, and on completion the script prints a summary (total tracks, unique album count, average rate, elapsed time, output path, and backup location if used) and logs the rebuild event via the shared MusicLib logging utilities. 

**musiclib_utils.sh**

A shared Bash utility library that centralizes common functions used across the MusicLib scripts, primarily focused on configuration loading, dependency validation, ID generation, metadata handling, and robust file/database management. It is designed to be sourced by other scripts so they can operate against a consistent configuration, logging, and error-handling framework while manipulating a flat-file database of tracks and their associated tags.

First, the script provides functions to load the main MusicLib configuration from `musiclib.conf`, verify that required tools like `exiftool`, `kid3-cli`, `kdeconnect-cli`, and `bc` are installed, and to check arbitrary tool requirements on demand. This ensures any consumer script fails fast with clear diagnostics if the environment is misconfigured or missing critical utilities, rather than failing later with opaque command errors. 

Second, it implements database helper functions for the DSV-backed music database, including computing the next available track ID, finding or creating album IDs, validating the database header format, and converting Unix epoch timestamps into the Excel/SQL serial date format used for LastTimePlayed fields. These helpers encapsulate all the row/field parsing logic (using `tail`, `awk`, `cut`, `grep`, `sort`, and `bc`) so higher-level scripts can treat the database as an abstracted service rather than hand-rolling parsing every time. 

Third, the script encapsulates track-level metadata and duration handling via `exiftool`, offering functions to extract artist/album/albumartist/title/genre into a caret-delimited record, to compute song lengths in milliseconds from mixed duration formats, and to convert that into the “seconds plus 000” length field convention. It also probes tag structure (ID3v1, ID3v2, APE) and whether a file has embedded album art, enabling consumer scripts to branch on tag presence or artwork state without duplicating the exiftool plumbing. 

Fourth, it provides an `update_lastplayed` routine that locates a track row by filepath, identifies the LastTimePlayed column index from the header, patches the DSV row in place, and then writes the same timestamp into a custom tag (Songs-DB_Custom1) via `kid3-cli` with automatic tag-rebuild-and-retry if a write fails. This gives you a single, consistent mechanism for synchronizing logical “last played” state between the flat-file database and on-disk tags, with logging hooks to capture any anomalies.

Fifth, `musiclib_utils.sh` contains generalized logging and backup utilities, including a `log_message` helper that timestamps messages to both stdout and a configured log file, plus routines to back up the main database (keeping only the latest five snapshots) and a generic `backup_file` that creates timestamped copies with verification and optional cleanup of aged backups by pattern. Additional helpers verify that backups match originals, remove backup artifacts, and prune stale files, giving the higher-level scripts a reusable, defensive layer for protecting and rotating persistent state.

Finally, the script introduces a more formal error and concurrency model with `error_exit` for JSON-formatted error reporting and a small file-locking framework for serialized database access. It tracks a global lock file descriptor (`DB_LOCK_FD`), implements `acquire_db_lock` and `release_db_lock`, and wraps arbitrary commands with `with_db_lock`, which sets traps to guarantee lock release on exit or signals, allowing multiple MusicLib components to coordinate safe concurrent access to the shared database without corrupting it. 

**musiclib_utils_tag_functions.sh**

Provides the tag-repair and normalization layer for the MusicLib system, focused on ID3v2 frames and safe, filtered rebuilding of tags using `exiftool` and `kid3-cli` as backends. It first manages an exclude list of “unwanted” or non-essential ID3v2 frames, loading this from configurable files or built-in defaults into an associative array, and exposes an `is_frame_allowed` helper so only approved frames (plus certain whitelisted `TXXX` user frames and ReplayGain fields) are ever written back into audio files. 

On top of that policy layer, it implements two main workflows: `rebuild_tag` for repairing corrupted tags on tracks already in the MusicLib database, and `normalize_new_track_tags` for cleaning up tags on new files before they are imported. Both functions extract full metadata and album art to a temp workspace, strip all existing ID3/APE tags, then rebuild clean ID3v2.3 tags—`rebuild_tag` pulling authoritative values (artist/album/title/rating, play tracking, grouping, etc.) from the MusicLib DB and preserving non-DB data like ReplayGain, while `normalize_new_track_tags` relies solely on the file’s current metadata. 

**musiclib_tagrebuild.sh** 

Repairs corrupted or malformed ID3 tags in MP3 files within a personal MusicLib database system. It targets files or directories specified by the user, processing only those entries present in the `musiclib.dsv` database, and extracts authoritative metadata like artist, album, title, and rating from the database while preserving non-database fields such as ReplayGain and album art. 

The script supports options for recursive directory scanning, dry-run previews, verbose logging, and custom backup directories, creating timestamped backups before modifications via the `rebuildtag` function from `musiclibutilstagfunctions.sh` (loaded dynamically). It skips non-database files non-fatally, tracks statistics on processed files, rebuilt tags, skips, and errors, and cleans up old backups older than a configurable age. 

**musiclib_process_pending.sh**

A deferred-execution handler that processes queued database operations created when lock contention prevents immediate writes during normal MusicLib workflows. When scripts like `musiclib_rate.sh` encounter a busy database, they write the pending operation (timestamp, script name, operation type, and arguments) to a `.pending_operations` queue file instead of failing, and then trigger this processor to retry them once the lock is released. The script can run automatically after database-writing operations complete, or be invoked manually or via a cron timer, making the rating/database system resilient to transient lock conflicts without user intervention.

Operationally, it acquires a non-blocking lock on the pending file to prevent concurrent processors from colliding, then iterates through each queued operation line-by-line, currently handling the `rate` operation which updates both the database (Rating and GroupDesc columns) and the file's ID3 tags (POPM and TIT1 frames) via `kid3-cli`. For each successful operation it removes the line from the queue, logs completion, and optionally fires a `kdialog` notification; if an operation still fails (e.g., database remains locked), it is left in the queue for the next retry cycle. On exit, the script cleans up malformed or unknown operations, deletes the queue file if empty, releases all locks, and returns exit code 0 (success or no pending work) or 2 (system error accessing the pending file), giving callers a clear signal of whether any backlog remains.



[1] Bounded between 30 seconds and 4 minutes means that, even though the script first computes the scrobble point as 50% of the track length, it then enforces a hard minimum of 30 seconds and a hard maximum of 240 seconds for that wait time. If half the track is shorter than 30 seconds it will still wait 30 seconds, and if half the track is longer than 4 minutes it will cap the wait at 4 minutes instead of waiting longer. The wait time matters because the script only scrobbles once it has observed that much continuous playback time on that specific track; if you pause for more than 4 minutes, you can break the assumption that “time elapsed since starting this track ≈ time actually listened.” The loop is literally counting three‑second “still playing this same file” checks up to a capped threshold (max 240 seconds), so any long pause (status no longer “playing” or file changed) stops the monitor and prevents a scrobble, even if wall‑clock time has marched past that 4‑minute cap.
