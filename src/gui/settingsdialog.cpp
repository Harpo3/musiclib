// settingsdialog.cpp
// MusicLib Qt GUI — Settings Dialog implementation
// Copyright (c) 2026 MusicLib Project

#include "settingsdialog.h"
#include "confwriter.h"
#include "musiclib.h"   // auto-generated by kconfig_compiler from musiclib.kcfg

#include <KLocalizedString>
#include <KUrlRequester>

#include <QCheckBox>
#include <QComboBox>
#include <QDir>
#include <QFormLayout>
#include <QGroupBox>
#include <QLabel>
#include <QLineEdit>
#include <QProcess>
#include <QPushButton>
#include <QSpinBox>
#include <QVBoxLayout>

// ═════════════════════════════════════════════════════════════
// Construction / Destruction
// ═════════════════════════════════════════════════════════════

SettingsDialog::SettingsDialog(QWidget *parent, ConfWriter *conf)
    : KConfigDialog(parent,
                    QStringLiteral("MusicLibSettings"),
                    MusicLibSettings::self())
    , m_conf(conf)
{
    // Build the variable-resolution table used by resolveConfVars().
    // This must happen before syncConfToKConfig() so that shell-style
    // references like ${MUSICLIB_DATA_DIR} are expanded to real paths
    // before KUrlRequester can percent-encode the braces.
    buildVarTable();

    // Sync musiclib.conf → KConfig so widgets show current values
    syncConfToKConfig();

    // Take a snapshot for hasChanged() comparison
    m_savedSnapshot = m_conf->allValues();

    // ── Add pages ──
    addPage(createGeneralPage(),
            i18n("General"),
            QStringLiteral("preferences-system"),
            i18n("Core paths and defaults"));

    addPage(createPlaybackMobilePage(),
            i18n("Playback && Mobile"),
            QStringLiteral("smartphone"),
            i18n("Audacious and KDE Connect settings"));

    addPage(createAdvancedPage(),
            i18n("Advanced"),
            QStringLiteral("configure"),
            i18n("Scripts, locking, and maintenance"));

    // Resize to something comfortable
    resize(560, 480);
}

SettingsDialog::~SettingsDialog()
{
}

// ═════════════════════════════════════════════════════════════
// Shell variable resolution
// ═════════════════════════════════════════════════════════════

void SettingsDialog::buildVarTable()
{
    // Populate a lookup table that maps shell variable patterns found in
    // musiclib.conf to their Qt-side equivalents.  The conf file uses
    // constructs like ${MUSICLIB_DATA_DIR} and $HOME which are resolved
    // by bash at source-time, but ConfWriter reads them as literal text.
    //
    // Resolution order matters: we resolve leaf variables first ($HOME),
    // then intermediate variables (MUSICLIB_XDG_*), then the variables
    // that depend on them (MUSICLIB_DATA_DIR), and finally any compound
    // variables that chain further (PLAYLISTS_DIR, MUSIC_DISPLAY_DIR).
    //
    // The init script generates the conf file from a heredoc where
    // $XDG_CONFIG_HOME and $XDG_DATA_HOME are expanded at write time,
    // so MUSICLIB_XDG_CONFIG and MUSICLIB_XDG_DATA are already absolute
    // paths on disk.  But MUSICLIB_DATA_DIR="$MUSICLIB_XDG_DATA" is
    // written with an escaped dollar sign, so ConfWriter reads it as
    // the literal string "$MUSICLIB_XDG_DATA".

    QString home = QDir::homePath();
    QString xdgConfig = home + QStringLiteral("/.config/musiclib");
    QString xdgData   = home + QStringLiteral("/.local/share/musiclib");

    // ── Helper: strip surrounding quotes and apply all current table
    //    entries to a string.  ConfWriter::value() may return the raw
    //    line value with its shell quotes intact, e.g. "$MUSICLIB_XDG_DATA".
    //    The quotes prevent pattern matching, so we strip them first. ──
    auto applyTable = [this](const QString &s) -> QString {
        QString out = s.trimmed();
        if (out.startsWith(QLatin1Char('"')) && out.endsWith(QLatin1Char('"'))) {
            out = out.mid(1, out.length() - 2);
        }
        for (const auto &entry : m_varTable) {
            if (out.contains(entry.first)) {
                out.replace(entry.first, entry.second);
            }
        }
        return out;
    };

    // ── Start with a clean table ──
    m_varTable.clear();

    // ── Layer 0: $HOME (leaf — no dependencies) ──
    m_varTable.append({QStringLiteral("${HOME}"), home});
    m_varTable.append({QStringLiteral("$HOME"),   home});

    // ── Layer 1: XDG environment variables ──
    // These are expanded by bash at conf-generation time, so the conf
    // file should already contain absolute paths for these keys.
    // But handle them defensively in case someone hand-edits the file.
    m_varTable.append({QStringLiteral("${XDG_CONFIG_HOME}"),
                       home + QStringLiteral("/.config")});
    m_varTable.append({QStringLiteral("$XDG_CONFIG_HOME"),
                       home + QStringLiteral("/.config")});
    m_varTable.append({QStringLiteral("${XDG_DATA_HOME}"),
                       home + QStringLiteral("/.local/share")});
    m_varTable.append({QStringLiteral("$XDG_DATA_HOME"),
                       home + QStringLiteral("/.local/share")});

    // ── Layer 2: MUSICLIB_XDG_CONFIG / MUSICLIB_XDG_DATA ──
    // Read from conf, resolve through current table, fall back to defaults.
    QString confXdgConfig = applyTable(
        m_conf->value(QStringLiteral("MUSICLIB_XDG_CONFIG"), xdgConfig));
    QString confXdgData = applyTable(
        m_conf->value(QStringLiteral("MUSICLIB_XDG_DATA"), xdgData));

    m_varTable.append({QStringLiteral("${MUSICLIB_XDG_CONFIG}"), confXdgConfig});
    m_varTable.append({QStringLiteral("$MUSICLIB_XDG_CONFIG"),   confXdgConfig});
    m_varTable.append({QStringLiteral("${MUSICLIB_XDG_DATA}"),   confXdgData});
    m_varTable.append({QStringLiteral("$MUSICLIB_XDG_DATA"),     confXdgData});

    // ── Layer 3: MUSICLIB_CONFIG_DIR / MUSICLIB_DATA_DIR ──
    // These typically reference the XDG variables from Layer 2.
    QString configDir = applyTable(
        m_conf->value(QStringLiteral("MUSICLIB_CONFIG_DIR"), confXdgConfig));
    QString dataDir = applyTable(
        m_conf->value(QStringLiteral("MUSICLIB_DATA_DIR"), confXdgData));

    // Bash default-value syntax: ${VAR:-default}
    // The system config (musiclib.conf_build) uses this form.
    // Handle it defensively — the init-generated conf uses the simpler form.
    m_varTable.append({QStringLiteral("${MUSICLIB_DATA_DIR:-$HOME/.local/share/musiclib}"),
                       dataDir});

    m_varTable.append({QStringLiteral("${MUSICLIB_CONFIG_DIR}"), configDir});
    m_varTable.append({QStringLiteral("$MUSICLIB_CONFIG_DIR"),   configDir});
    m_varTable.append({QStringLiteral("${MUSICLIB_DATA_DIR}"),   dataDir});
    m_varTable.append({QStringLiteral("$MUSICLIB_DATA_DIR"),     dataDir});

    // ── Layer 4: Compound variables that other conf lines reference ──
    QString playlistsDir = applyTable(
        m_conf->value(QStringLiteral("PLAYLISTS_DIR"),
                      dataDir + QStringLiteral("/playlists")));

    QString musicDisplayDir = applyTable(
        m_conf->value(QStringLiteral("MUSIC_DISPLAY_DIR"),
                      dataDir + QStringLiteral("/data/conky_output")));

    m_varTable.append({QStringLiteral("$PLAYLISTS_DIR"),     playlistsDir});
    m_varTable.append({QStringLiteral("$MUSIC_DISPLAY_DIR"), musicDisplayDir});
}

QString SettingsDialog::resolveConfVars(const QString &raw) const
{
    // Strip surrounding double quotes — ConfWriter::value() may return
    // the raw shell-quoted value, e.g. "${MUSICLIB_DATA_DIR}/data/musiclib.dsv".
    // The quotes would prevent pattern matching against $-variables.
    QString resolved = raw.trimmed();
    if (resolved.startsWith(QLatin1Char('"')) && resolved.endsWith(QLatin1Char('"'))) {
        resolved = resolved.mid(1, resolved.length() - 2);
    }

    // Apply every pattern→replacement pair from the variable table.
    // The table is built in dependency order (leaves first), so a
    // single pass is sufficient — each replacement produces only
    // absolute path fragments, never new variable references.
    for (const auto &entry : m_varTable) {
        if (resolved.contains(entry.first)) {
            resolved.replace(entry.first, entry.second);
        }
    }
    return resolved;
}

// ═════════════════════════════════════════════════════════════
// Page builders
// ═════════════════════════════════════════════════════════════

QWidget *SettingsDialog::createGeneralPage()
{
    auto *page = new QWidget(this);
    auto *layout = new QVBoxLayout(page);

    // ── Paths group ──
    auto *pathsGroup = new QGroupBox(i18n("Paths"), page);
    auto *pathsForm = new QFormLayout(pathsGroup);

    m_musicRepoUrl = new KUrlRequester(pathsGroup);
    m_musicRepoUrl->setMode(KFile::Directory | KFile::ExistingOnly | KFile::LocalOnly);
    m_musicRepoUrl->setObjectName(QStringLiteral("kcfg_MusicRepo"));
    m_musicRepoUrl->setToolTip(
        i18n("Root directory of your music collection.\n"
             "All tracks are expected under Artist/Album/ subdirectories.\n"
             "Example: /home/user/Music"));
    pathsForm->addRow(i18n("Music repository:"), m_musicRepoUrl);

    m_databaseUrl = new KUrlRequester(pathsGroup);
    m_databaseUrl->setMode(KFile::File | KFile::LocalOnly);
    m_databaseUrl->setObjectName(QStringLiteral("kcfg_MusicDatabase"));
    m_databaseUrl->setToolTip(
        i18n("Path to the MusicLib database file (musiclib.dsv).\n"
             "This caret-delimited file stores all track metadata,\n"
             "ratings, and play history. Created by the Build operation."));
    pathsForm->addRow(i18n("Database file:"), m_databaseUrl);

    m_downloadDirUrl = new KUrlRequester(pathsGroup);
    m_downloadDirUrl->setMode(KFile::Directory | KFile::ExistingOnly | KFile::LocalOnly);
    m_downloadDirUrl->setObjectName(QStringLiteral("kcfg_NewDownloadDir"));
    m_downloadDirUrl->setToolTip(
        i18n("Directory where newly downloaded or unzipped music\n"
             "is placed before importing into the library.\n"
             "The 'New Tracks' operation reads from this folder."));
    pathsForm->addRow(i18n("Download directory:"), m_downloadDirUrl);

    layout->addWidget(pathsGroup);

    // ── Defaults group ──
    auto *defaultsGroup = new QGroupBox(i18n("New Track Defaults"), page);
    auto *defaultsForm = new QFormLayout(defaultsGroup);

    m_defaultRatingSpin = new QSpinBox(defaultsGroup);
    m_defaultRatingSpin->setRange(0, 5);
    m_defaultRatingSpin->setSuffix(i18n(" stars"));
    m_defaultRatingSpin->setObjectName(QStringLiteral("kcfg_DefaultRating"));
    m_defaultRatingSpin->setToolTip(
        i18n("Star rating assigned to newly imported tracks.\n"
             "0 = unrated, 1–5 = star rating.\n"
             "You can change individual ratings later."));
    defaultsForm->addRow(i18n("Default rating:"), m_defaultRatingSpin);

    m_defaultGroupDescSpin = new QSpinBox(defaultsGroup);
    m_defaultGroupDescSpin->setRange(0, 5);
    m_defaultGroupDescSpin->setObjectName(QStringLiteral("kcfg_DefaultGroupDesc"));
    m_defaultGroupDescSpin->setToolTip(
        i18n("Group descriptor assigned to newly imported tracks.\n"
             "This is a custom numeric field (0–5) you can use\n"
             "for any categorization purpose — e.g., mood, energy\n"
             "level, or playlist grouping."));
    defaultsForm->addRow(i18n("Default group descriptor:"), m_defaultGroupDescSpin);

    layout->addWidget(defaultsGroup);
    layout->addStretch();

    return page;
}

QWidget *SettingsDialog::createPlaybackMobilePage()
{
    auto *page = new QWidget(this);
    auto *layout = new QVBoxLayout(page);

    // ── Audacious group ──
    auto *audGroup = new QGroupBox(i18n("Audacious"), page);
    auto *audForm = new QFormLayout(audGroup);

    m_audaciousPlaylistsDirUrl = new KUrlRequester(audGroup);
    m_audaciousPlaylistsDirUrl->setMode(
        KFile::Directory | KFile::ExistingOnly | KFile::LocalOnly);
    m_audaciousPlaylistsDirUrl->setObjectName(
        QStringLiteral("kcfg_AudaciousPlaylistsDir"));
    m_audaciousPlaylistsDirUrl->setToolTip(
        i18n("Directory where Audacious stores its playlist files.\n"
             "MusicLib replicates these for playlist management.\n"
             "Default: ~/.config/audacious/playlists"));
    audForm->addRow(i18n("Playlists directory:"), m_audaciousPlaylistsDirUrl);

    m_scrobbleThresholdSpin = new QSpinBox(audGroup);
    m_scrobbleThresholdSpin->setRange(1, 100);
    m_scrobbleThresholdSpin->setSuffix(QStringLiteral("%"));
    m_scrobbleThresholdSpin->setObjectName(
        QStringLiteral("kcfg_ScrobbleThresholdPct"));
    m_scrobbleThresholdSpin->setToolTip(
        i18n("Percentage of a song that must play before it counts\n"
             "as 'played' and updates the Last Time Played field.\n"
             "Example: 50%% means at least half the track must play.\n"
             "Lower values catch skipped-through tracks; higher\n"
             "values only count fully listened songs."));
    audForm->addRow(i18n("Scrobble threshold:"), m_scrobbleThresholdSpin);

    layout->addWidget(audGroup);

    // ── KDE Connect / Mobile group ──
    auto *mobileGroup = new QGroupBox(i18n("KDE Connect / Mobile"), page);
    auto *mobileForm = new QFormLayout(mobileGroup);

    // Device ID row: text field + detect button side by side
    auto *deviceRow = new QWidget(mobileGroup);
    auto *deviceLayout = new QHBoxLayout(deviceRow);
    deviceLayout->setContentsMargins(0, 0, 0, 0);

    m_deviceIdEdit = new QLineEdit(deviceRow);
    m_deviceIdEdit->setPlaceholderText(i18n("e.g. a1b2c3d4_e5f6_7890..."));
    m_deviceIdEdit->setObjectName(QStringLiteral("kcfg_DeviceId"));
    m_deviceIdEdit->setToolTip(
        i18n("KDE Connect device identifier for your Android phone.\n"
             "Used by Mobile Sync to transfer playlists and tracks.\n"
             "Click 'Detect' to scan for paired devices, or find it\n"
             "manually with: kdeconnect-cli -a"));
    deviceLayout->addWidget(m_deviceIdEdit, 1);

    m_detectDevicesBtn = new QPushButton(i18n("Detect"), deviceRow);
    m_detectDevicesBtn->setIcon(QIcon::fromTheme(QStringLiteral("edit-find")));
    m_detectDevicesBtn->setToolTip(
        i18n("Scan for paired KDE Connect devices"));
    connect(m_detectDevicesBtn, &QPushButton::clicked,
            this, &SettingsDialog::onDetectDevices);
    deviceLayout->addWidget(m_detectDevicesBtn);

    mobileForm->addRow(i18n("Device ID:"), deviceRow);

    m_mobileWindowDaysSpin = new QSpinBox(mobileGroup);
    m_mobileWindowDaysSpin->setRange(1, 365);
    m_mobileWindowDaysSpin->setSuffix(i18n(" days"));
    m_mobileWindowDaysSpin->setObjectName(
        QStringLiteral("kcfg_MobileWindowDays"));
    m_mobileWindowDaysSpin->setToolTip(
        i18n("Maximum number of days since the last mobile upload\n"
             "before a warning is shown. This helps remind you to\n"
             "sync your phone playlist periodically.\n"
             "Example: 40 days means you'll be prompted if it's\n"
             "been more than 40 days since the last upload."));
    mobileForm->addRow(i18n("Mobile window:"), m_mobileWindowDaysSpin);

    m_minPlayWindowSpin = new QSpinBox(mobileGroup);
    m_minPlayWindowSpin->setRange(60, 86400);
    m_minPlayWindowSpin->setSuffix(i18n(" sec"));
    m_minPlayWindowSpin->setObjectName(QStringLiteral("kcfg_MinPlayWindow"));
    m_minPlayWindowSpin->setToolTip(
        i18n("Minimum time window (in seconds) used to generate\n"
             "synthetic timestamps when processing mobile play history.\n"
             "Since Android doesn't report exact play times, MusicLib\n"
             "spreads plays evenly across this window.\n"
             "Default: 3600 (1 hour). Larger values space plays further apart."));
    mobileForm->addRow(i18n("Min play window:"), m_minPlayWindowSpin);

    layout->addWidget(mobileGroup);
    layout->addStretch();

    return page;
}

QWidget *SettingsDialog::createAdvancedPage()
{
    auto *page = new QWidget(this);
    auto *layout = new QVBoxLayout(page);

    // ── Scripts & System group ──
    auto *sysGroup = new QGroupBox(i18n("System"), page);
    auto *sysForm = new QFormLayout(sysGroup);

    m_scriptsDirUrl = new KUrlRequester(sysGroup);
    m_scriptsDirUrl->setMode(
        KFile::Directory | KFile::ExistingOnly | KFile::LocalOnly);
    m_scriptsDirUrl->setObjectName(QStringLiteral("kcfg_ScriptsDir"));
    m_scriptsDirUrl->setToolTip(
        i18n("Directory containing MusicLib backend shell scripts.\n"
             "Default: /usr/lib/musiclib/bin\n"
             "Change only if you installed scripts to a custom location."));
    sysForm->addRow(i18n("Scripts directory:"), m_scriptsDirUrl);

    auto *scriptsWarning = new QLabel(
        i18n("<i>Change only if you installed scripts to a non-standard path.</i>"),
        sysGroup);
    scriptsWarning->setWordWrap(true);
    sysForm->addRow(QString(), scriptsWarning);

    m_lockTimeoutSpin = new QSpinBox(sysGroup);
    m_lockTimeoutSpin->setRange(1, 30);
    m_lockTimeoutSpin->setSuffix(i18n(" sec"));
    m_lockTimeoutSpin->setObjectName(QStringLiteral("kcfg_LockTimeout"));
    m_lockTimeoutSpin->setToolTip(
        i18n("Maximum time (in seconds) to wait for the database lock.\n"
             "MusicLib uses file locking to prevent concurrent writes.\n"
             "If another operation holds the lock longer than this,\n"
             "the current operation will be queued for retry.\n"
             "Default: 5 seconds. Increase if you see frequent lock errors."));
    sysForm->addRow(i18n("Lock timeout:"), m_lockTimeoutSpin);

    layout->addWidget(sysGroup);

    // ── Directories group ──
    auto *dirsGroup = new QGroupBox(i18n("Output Directories"), page);
    auto *dirsForm = new QFormLayout(dirsGroup);

    m_conkyOutputDirUrl = new KUrlRequester(dirsGroup);
    m_conkyOutputDirUrl->setMode(
        KFile::Directory | KFile::ExistingOnly | KFile::LocalOnly);
    m_conkyOutputDirUrl->setObjectName(QStringLiteral("kcfg_ConkyOutputDir"));
    m_conkyOutputDirUrl->setToolTip(
        i18n("Directory where MusicLib writes now-playing data files\n"
             "(artist, title, rating images, etc.) for Conky or the\n"
             "Plasma widget to display on your desktop.\n"
             "These files are updated each time a song changes."));
    dirsForm->addRow(i18n("Conky output:"), m_conkyOutputDirUrl);

    m_tagBackupDirUrl = new KUrlRequester(dirsGroup);
    m_tagBackupDirUrl->setMode(
        KFile::Directory | KFile::ExistingOnly | KFile::LocalOnly);
    m_tagBackupDirUrl->setObjectName(QStringLiteral("kcfg_TagBackupDir"));
    m_tagBackupDirUrl->setToolTip(
        i18n("Directory where MP3 backup copies are stored before\n"
             "tag-modifying operations (tag clean, tag rebuild).\n"
             "Backups are automatically deleted after the retention\n"
             "period set below."));
    dirsForm->addRow(i18n("Tag backups:"), m_tagBackupDirUrl);

    m_backupAgeDaysSpin = new QSpinBox(dirsGroup);
    m_backupAgeDaysSpin->setRange(1, 365);
    m_backupAgeDaysSpin->setSuffix(i18n(" days"));
    m_backupAgeDaysSpin->setObjectName(QStringLiteral("kcfg_MaxBackupAgeDays"));
    m_backupAgeDaysSpin->setToolTip(
        i18n("Number of days to keep tag backup files before they\n"
             "are automatically purged. Longer retention uses more\n"
             "disk space but gives you a bigger safety net.\n"
             "Default: 30 days."));
    dirsForm->addRow(i18n("Backup retention:"), m_backupAgeDaysSpin);

    layout->addWidget(dirsGroup);

    // ── GUI group (KConfig-only settings, not in musiclib.conf) ──
    auto *guiGroup = new QGroupBox(i18n("GUI Behavior"), page);
    auto *guiForm = new QFormLayout(guiGroup);

    m_pollIntervalSpin = new QSpinBox(guiGroup);
    m_pollIntervalSpin->setRange(1000, 30000);
    m_pollIntervalSpin->setSingleStep(500);
    m_pollIntervalSpin->setSuffix(i18n(" ms"));
    m_pollIntervalSpin->setObjectName(
        QStringLiteral("kcfg_NowPlayingPollInterval"));
    m_pollIntervalSpin->setToolTip(
        i18n("How often (in milliseconds) MusicLib checks Audacious\n"
             "for the currently playing track. Lower values give\n"
             "faster updates but use slightly more CPU.\n"
             "Default: 3000 ms (3 seconds).\n"
             "Range: 1000 ms (1 sec) to 30000 ms (30 sec)."));
    guiForm->addRow(i18n("Now-playing poll:"), m_pollIntervalSpin);

    layout->addWidget(guiGroup);

    // ── Info row ──
    m_apiVersionLabel = new QLabel(page);
    m_apiVersionLabel->setText(
        i18n("Backend API version: %1",
             m_conf->value(QStringLiteral("BACKEND_API_VERSION"),
                           QStringLiteral("unknown"))));
    m_apiVersionLabel->setToolTip(
        i18n("Version of the shell script backend API.\n"
             "The GUI checks this for compatibility on startup.\n"
             "This is read-only — it is set by the installed scripts."));
    layout->addWidget(m_apiVersionLabel);

    layout->addStretch();

    return page;
}

// ═════════════════════════════════════════════════════════════
// KConfigDialog overrides — sync hooks
// ═════════════════════════════════════════════════════════════

void SettingsDialog::updateSettings()
{
    // KConfigDialog has already written widget values → KConfig.
    // Now sync KConfig → musiclib.conf so the shell scripts see changes.
    syncKConfigToConf();

    // Take a fresh snapshot
    m_savedSnapshot = m_conf->allValues();

    // Emit signals for values that affect live GUI behavior.
    // Compare old and new to only signal actual changes.
    Q_EMIT databasePathChanged();
    Q_EMIT deviceIdChanged();
    Q_EMIT systemTraySettingsChanged();
    Q_EMIT pollIntervalChanged(
        MusicLibSettings::self()->nowPlayingPollInterval());
}

void SettingsDialog::updateWidgets()
{
    // KConfigDialog calls this to populate widgets from KConfig.
    // We first refresh KConfig from musiclib.conf (in case the file
    // was edited externally since the dialog was last opened).
    buildVarTable();       // rebuild in case conf was edited externally
    syncConfToKConfig();
    m_savedSnapshot = m_conf->allValues();

    // Update the API version label (read-only, not in KConfig)
    m_apiVersionLabel->setText(
        i18n("Backend API version: %1",
             m_conf->value(QStringLiteral("BACKEND_API_VERSION"),
                           QStringLiteral("unknown"))));
}

bool SettingsDialog::hasChanged()
{
    // Let KConfigDialog check its managed widgets against KConfig.
    // We also check if the conf writer has unsaved changes, though
    // in practice KConfigDialog's own check covers the widgets.
    return KConfigDialog::hasChanged();
}

// ═════════════════════════════════════════════════════════════
// Conf ↔ KConfig synchronization
// ═════════════════════════════════════════════════════════════

void SettingsDialog::syncConfToKConfig()
{
    // Direction: musiclib.conf → KConfig
    // Called on startup and when the dialog is opened.
    //
    // Because MusicLibSettings is a SINGLETON, the generated setters are
    // static free functions (not member functions).  We call them directly.
    //
    // Every path value from the conf file is run through resolveConfVars()
    // to expand shell variable references (e.g. ${MUSICLIB_DATA_DIR})
    // into real filesystem paths.  Without this, KUrlRequester would
    // percent-encode the braces and show garbled paths like
    // $%7BMUSICLIB_DATA_DIR%7D.

    QString home = QDir::homePath();
    QString xdgData = home + QStringLiteral("/.local/share/musiclib");

    // ── Paths (resolve shell variables before storing) ──
    MusicLibSettings::setMusicRepo(resolveConfVars(
        m_conf->value(QStringLiteral("MUSIC_REPO"),
                      home + QStringLiteral("/Music"))));

    MusicLibSettings::setMusicDatabase(resolveConfVars(
        m_conf->value(QStringLiteral("MUSICDB"),
                      xdgData + QStringLiteral("/data/musiclib.dsv"))));

    MusicLibSettings::setPlaylistsDir(resolveConfVars(
        m_conf->value(QStringLiteral("PLAYLISTS_DIR"),
                      xdgData + QStringLiteral("/playlists"))));

    MusicLibSettings::setNewDownloadDir(resolveConfVars(
        m_conf->value(QStringLiteral("NEW_DOWNLOAD_DIR"),
                      home + QStringLiteral("/Downloads"))));

    MusicLibSettings::setScriptsDir(resolveConfVars(
        m_conf->value(QStringLiteral("SCRIPTS_DIR"),
                      QStringLiteral("/usr/lib/musiclib/bin"))));

    MusicLibSettings::setConkyOutputDir(resolveConfVars(
        m_conf->value(QStringLiteral("MUSIC_DISPLAY_DIR"),
                      xdgData + QStringLiteral("/data/conky_output"))));

    MusicLibSettings::setTagBackupDir(resolveConfVars(
        m_conf->value(QStringLiteral("TAG_BACKUP_DIR"),
                      xdgData + QStringLiteral("/data/tag_backups"))));

    MusicLibSettings::setLogFile(resolveConfVars(
        m_conf->value(QStringLiteral("LOGFILE"),
                      xdgData + QStringLiteral("/logs/musiclib.log"))));

    // ── Audacious ──
    MusicLibSettings::setAudaciousPlaylistsDir(resolveConfVars(
        m_conf->value(QStringLiteral("AUDACIOUS_PLAYLISTS_DIR"),
                      home + QStringLiteral("/.config/audacious/playlists"))));

    MusicLibSettings::setScrobbleThresholdPct(
        m_conf->intValue(QStringLiteral("SCROBBLE_THRESHOLD_PCT"), 50));

    // ── Mobile ──
    MusicLibSettings::setDeviceId(
        m_conf->value(QStringLiteral("DEVICE_ID"), QString()));

    MusicLibSettings::setMinPlayWindow(
        m_conf->intValue(QStringLiteral("MIN_PLAY_WINDOW"), 3600));

    MusicLibSettings::setMobileWindowDays(
        m_conf->intValue(QStringLiteral("MOBILE_WINDOW_DAYS"), 40));

    // ── Database ──
    MusicLibSettings::setDefaultRating(
        m_conf->intValue(QStringLiteral("DEFAULT_RATING"), 0));

    MusicLibSettings::setDefaultGroupDesc(
        m_conf->intValue(QStringLiteral("DEFAULT_GROUPDESC"), 0));

    MusicLibSettings::setLockTimeout(
        m_conf->intValue(QStringLiteral("LOCK_TIMEOUT"), 5));

    MusicLibSettings::setMaxBackupAgeDays(
        m_conf->intValue(QStringLiteral("MAX_BACKUP_AGE_DAYS"), 30));

    MusicLibSettings::self()->save();
}

void SettingsDialog::syncKConfigToConf()
{
    // Direction: KConfig → musiclib.conf
    // Called after Apply/OK to persist changes for the shell scripts.
    //
    // Values are written as resolved absolute paths.  The shell scripts
    // use 'source musiclib.conf' which evaluates each line, so absolute
    // paths work identically to variable references.  The MUSICLIB_DATA_DIR
    // and MUSICLIB_XDG_DATA definition lines are preserved in the conf
    // file by ConfWriter (it only updates keys that are explicitly set
    // here), so the variable definitions remain available for any manual
    // editing.
    auto *s = MusicLibSettings::self();

    // ── Paths (written as resolved absolute paths) ──
    m_conf->setValue(QStringLiteral("MUSIC_REPO"),   s->musicRepo());
    m_conf->setValue(QStringLiteral("MUSICDB"),      s->musicDatabase());
    m_conf->setValue(QStringLiteral("PLAYLISTS_DIR"), s->playlistsDir());
    m_conf->setValue(QStringLiteral("NEW_DOWNLOAD_DIR"), s->newDownloadDir());
    m_conf->setValue(QStringLiteral("SCRIPTS_DIR"),  s->scriptsDir());
    m_conf->setValue(QStringLiteral("MUSIC_DISPLAY_DIR"), s->conkyOutputDir());
    m_conf->setValue(QStringLiteral("TAG_BACKUP_DIR"), s->tagBackupDir());
    m_conf->setValue(QStringLiteral("LOGFILE"),      s->logFile());

    // ── Audacious ──
    m_conf->setValue(QStringLiteral("AUDACIOUS_PLAYLISTS_DIR"),
                     s->audaciousPlaylistsDir());
    m_conf->setIntValue(QStringLiteral("SCROBBLE_THRESHOLD_PCT"),
                        s->scrobbleThresholdPct());

    // ── Mobile ──
    m_conf->setValue(QStringLiteral("DEVICE_ID"), s->deviceId());
    m_conf->setIntValue(QStringLiteral("MIN_PLAY_WINDOW"),
                        s->minPlayWindow());
    m_conf->setIntValue(QStringLiteral("MOBILE_WINDOW_DAYS"),
                        s->mobileWindowDays());

    // ── Database ──
    m_conf->setIntValue(QStringLiteral("DEFAULT_RATING"),
                        s->defaultRating());
    m_conf->setIntValue(QStringLiteral("DEFAULT_GROUPDESC"),
                        s->defaultGroupDesc());
    m_conf->setIntValue(QStringLiteral("LOCK_TIMEOUT"),
                        s->lockTimeout());
    m_conf->setIntValue(QStringLiteral("MAX_BACKUP_AGE_DAYS"),
                        s->maxBackupAgeDays());

    // Write to disk
    m_conf->save();
}

// ═════════════════════════════════════════════════════════════
// Device detection
// ═════════════════════════════════════════════════════════════

void SettingsDialog::onDetectDevices()
{
    m_detectDevicesBtn->setEnabled(false);
    m_detectDevicesBtn->setText(i18n("Scanning..."));

    QProcess proc;
    proc.start(QStringLiteral("kdeconnect-cli"),
               {QStringLiteral("-l")});

    if (!proc.waitForFinished(5000)) {
        proc.kill();
        m_detectDevicesBtn->setEnabled(true);
        m_detectDevicesBtn->setText(i18n("Detect"));
        m_deviceIdEdit->setPlaceholderText(
            i18n("kdeconnect-cli timed out"));
        return;
    }

    if (proc.exitCode() != 0) {
        m_detectDevicesBtn->setEnabled(true);
        m_detectDevicesBtn->setText(i18n("Detect"));
        m_deviceIdEdit->setPlaceholderText(
            i18n("kdeconnect-cli not found or failed"));
        return;
    }

    // Parse output lines.  Format:
    //   - DeviceName: xxxxxxxx_xxxx_xxxx (paired and reachable)
    //   - DeviceName: xxxxxxxx_xxxx_xxxx (paired)
    // We want lines containing "paired".
    QString output = QString::fromUtf8(proc.readAllStandardOutput());
    QStringList lines = output.split(QLatin1Char('\n'), Qt::SkipEmptyParts);

    struct DeviceInfo {
        QString name;
        QString id;
    };
    QList<DeviceInfo> devices;

    for (const QString &line : lines) {
        if (!line.contains(QStringLiteral("paired"))) {
            continue;
        }

        // Extract: "- Name: id_string (status)"
        int colonPos = line.indexOf(QLatin1Char(':'));
        int parenPos = line.lastIndexOf(QLatin1Char('('));
        if (colonPos < 0 || parenPos < 0) {
            continue;
        }

        QString name = line.mid(2, colonPos - 2).trimmed();  // skip "- "
        QString id = line.mid(colonPos + 1, parenPos - colonPos - 1).trimmed();

        if (!id.isEmpty()) {
            devices.append({name, id});
        }
    }

    m_detectDevicesBtn->setEnabled(true);
    m_detectDevicesBtn->setText(i18n("Detect"));

    if (devices.isEmpty()) {
        m_deviceIdEdit->setPlaceholderText(
            i18n("No paired devices found"));
        return;
    }

    if (devices.size() == 1) {
        // Single device — auto-fill
        m_deviceIdEdit->setText(devices.first().id);
        return;
    }

    // Multiple devices — show a quick-pick menu via a popup combo
    // (Replacing the line edit text with a selector is too disruptive,
    // so we just fill the first one and put a tooltip listing all.)
    m_deviceIdEdit->setText(devices.first().id);
    QString tooltip = i18n("Detected devices:\n");
    for (const auto &d : devices) {
        tooltip += QStringLiteral("  %1  →  %2\n").arg(d.name, d.id);
    }
    m_deviceIdEdit->setToolTip(tooltip);
}
